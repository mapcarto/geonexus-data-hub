# GeoNexus 架构：Koop Provider 开发规范与性能指南
## 1. 核心设计哲学：Koop 作为“装配车间”，而非“冶炼厂”
在 GeoNexus 架构中，Koop 要素引擎 (feature-engine) 的核心定位是一个**高性能的数据“装配车间” (Assembly Line)**。它的职责是接收来自上游数据源（如 PostGIS）的、结构相对清晰的“标准零件”，然后进行轻量级的、实时的“组装”，最终输出为标准的地理空间服务（如 GeoJSON）。
与此相对，Koop **不应该**扮演“数据冶炼厂 (Smelter)”的角色。所有计算密集型、耗时长的“矿石提炼”工作——例如复杂的空间分析、大规模数据聚合——都应该在数据到达 Koop **之前**完成。这些重度计算任务应尽可能**“下推” (Push Down)** 到更适合执行它们的后端（如 PostGIS 数据库）或在数据入库前通过离线的 ETL 流程进行预处理。
遵循这一核心哲学，是保证 Koop 服务保持低延迟和高吞吐的关键。
## 2. 转换复杂度评估指南
本指南旨在为 Provider 的开发提供清晰的界线，明确哪些转换逻辑适合在 Koop 中实时执行，哪些则必须避免。
### ✅ 绿色通道：推荐在 Koop 中执行的操作 (低性能影响)
以下操作属于轻量级的、逐要素 (Per-Feature) 的处理，对 Node.js 的事件循环影响极小，是 Koop 的理想工作负载。
属性映射与重命名: 将数据源字段重命名为标准的 GeoJSON 属性。
示例: feature.properties.name = db_row.building_name;
基本数据格式化: 对字符串、数字、日期等进行格式化或拼接。
示例: feature.properties.full_address =  `${db_row.street} ${db_row.number}号 `;
简单条件逻辑: 基于属性值进行简单的 if/else 或 switch 判断，以映射枚举值或状态。
示例: if (db_row.status === 1) feature.properties.status_text = '正常';
简单坐标投影: 对要素的几何坐标进行标准的投影转换（如从 EPSG:3857 转为 EPSG:4326）。
原因: 专用的投影库 (proj4.js 等) 对坐标点的数学计算经过高度优化，性能开销在可接受范围内。
### ❌ 红色警报：禁止在 Koop 中执行的操作 (高性能风险)
以下操作属于计算密集型或 I/O 密集型任务，**严禁**在 Koop 的实时转换逻辑中执行。它们会严重阻塞事件循环，导致服务性能急剧下降甚至无响应。
复杂的空间分析:
严禁示例: 缓冲区 (Buffer), 相交 (Intersection), 合并 (Union), 几何简化 (Simplification)。
正确做法: 必须将这些操作下推到数据库层。在 postgis-provider 中，应直接编写包含 ST_Buffer(), ST_Intersection() 等 PostGIS 空间函数的 SQL 查询。
大规模数据聚合:
严禁示例: 对返回的数千个要素进行 分组计数 (Group By)、求和 (Sum) 或 求平均 (Average)。
正确做法: 必须将聚合计算下推到数据库层。直接在 SQL 查询中使用 COUNT(), AVG(), GROUP BY 等聚合子句。
循环中的外部 API 请求 (N+1 查询):
严禁示例: 在 for 循环中，为每个要素都发起一次独立的 HTTP 请求去“丰富”其属性。
正确做法:
首选（预处理）: 在数据入库前，通过离线脚本完成属性的丰富化并存入数据库。
次选（批量请求）: 如果必须实时请求，应在循环外收集所有需要查询的 ID，然后调用支持批量查询的外部 API 接口，将 N+1 次请求合并为 1 次。
## 3. 决策流程图
```mermaid
graph TD
    A[开始：收到新的转换需求] --> B{转换逻辑的类型是什么？};
    B --> C{是轻量级的逐要素操作吗？<br>(属性映射、简单格式化、<br>简单条件、标准坐标投影)};
    C -->|是| D[✅ 绿色通道：在 Koop Provider 中执行];
    C -->|否| E{是计算密集型或 I/O 密集型操作吗？};
    E --> F{是复杂的空间分析吗？<br>(Buffer, Intersection等)};
    F -->|是| G[❌ 红色警报：下推到数据库<br>(例如, 使用 PostGIS 的 ST_Buffer())];
    F -->|否| H{是大规模数据聚合吗？<br>(Group By, Sum, Avg等)};
    H -->|是| I[❌ 红色警报：下推到数据库<br>(例如, 使用 SQL 的 COUNT(), GROUP BY)];
    H -->|否| J{是否会在循环中为每个要素<br>调用外部 API (N+1 查询)？};
    J -->|是| K[❌ 红色警报：重构为批量请求<br>或通过离线 ETL 预处理];
    J -->|否| L[🤔 重新评估：<br>若不属于以上情况，<br>请与架构师讨论];
```